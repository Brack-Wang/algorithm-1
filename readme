算法描述

尝试使用C/C++ 使用描述（实现）一些算法，希望在此交流互相学习。
若你发现其中存在问题，可以随时联系本人。
e-mail：huangjunkun@gmail.com

欢迎交流，谢谢！

## 8.
## 7.
## 6.

## 5.
/**
** 源文件： convex_hull.h, convex_hull.cpp
** 功能：凸包问题的解决方案, 蛮力法与分治法.
** 蛮力法使用到几何知识:
 P1，P2{(x1, y1), (x2, y2)} => ax + by = c
 => {a = y2-y1, b = x1 - x2, c = x1y2 - y1x2}
 使用公式ax + by = c可判断点P3(x3, y3)落在{(x1, y1), (x2, y2)}哪边.
蛮力解法步骤：
1. 循环遍历所有的点，找出所有像P1，P2的点，需满足条件：
 其他所有的点均分布在直线P1P2同一边，借助以上几何知识。
2. 找出了所有这样的点，那么就完成凸包问题。

蛮力解决方案时间复杂度O(n^3).

** 分治法使用到几何知识:
 {(x1, y1), (x2, y2), (x3, y3)} P1, P2, P3.面积S(P1P2P3)为以下行列式绝对值的一半，
 |x1 y1 1|
 |x2 y2 1| = x1y2 + x3y1 + x2y3 - x3y2 - x2y1 - x1y3
 |x3 y3 1|
 P3位于直线P1P2的左侧时，该表达式为正值。
 P3位于直线P1P2的右侧时，该表达式为负值。
 该绝对值越大，即P3就与直线P1P2距离越大。
分治解法步骤：
1. 按照X轴（或Y轴）排序点集合S0，得到最小大值P1，Pn，并划分上包，下包不同点集合。
2. 以上包为例，根据以上几何知识，找出上包顶点Pmax即距离P1Pn最远的点，找不到即结束。
3. 继续以P1Pmax和PmaxPn构造上包，递归下去直至找不到上包顶点。得到点集合S1.
4. 下包操作同。得到点集合S2.
5. 合并集合S1, S2, 得到S3即凸包结果.

分治法解决方案时间复杂度O(n^2).
btw 详细的算法可以参见<算法分析与设计> 3.蛮力法3.3.2凸包问题 & 4.分治法4.6.2凸包问题.
** 算法实现详见以上源文件代码.
** 凸包问题描述:
	定理:任意包含n>2个点（不共线）的集合S的凸包是以S中的某些点为顶点的凸多边形。
	凸包问题是为一个n个点的集合构造凸包的问题。
	极点：对于任何一集合中的点为端点的线段来说，它们不是这种线段的中点。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 日期：2009-09-20 /
*/

## 4.
/**
** 源文件： min_spanning_tree.cpp
** 功能说明：
** 测试程序，最小生成树问题CMST解决方案Prim算法与Kruskal算法。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

## 3.
/**
** 源文件： nearest_neighbor_search.cpp
** 功能说明：
** 测试程序，最近点对问题解决方案，蛮力法与分治法。详见以下代码。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

## 2.
/**
** 源文件： shortest_path.cpp
** 功能说明：
** 测试程序，最短路径问题解决方案，Floyd算法与Dijkstra算法。详见以下代码。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

## 1.

/**
** 源文件： random_list_node.h, random_list_node_test.cpp
** 功能：拷贝“随机链表”，即节点带有一个指针可能指向链表随机另一个节点的链表。
** 一般的简单蛮力算法，可完成该功能，但时间复杂度为 O(n*m)。而以下算法较高效，相比时间复杂度为O(m).
** 具体操作，需要遍历源链表三遍。包括拷贝链表+复制随机指针+回复源链表NEXT指针。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 日期：2011-06-10 /
*/
